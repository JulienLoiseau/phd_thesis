%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                   %
%	CHAPTER ONE, CHOICES AND SPH                                    %
%                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{General problem}

\section{Introduction}
In this section we give details on our choices for the generic application confronted to both computation and communication walls in irregular context. 
This problem, the Smoothed Particle Hydrodynamics method implementation, is described on a physics aspect.
We point out the difficulties involved in the resolution on supercomputers and more especially accelerators.  
A lot of work have been done on the comprehension of the physical aspect to produce a code that meet the behavior of real physics problems.

The first section is a presentation of the SPH method itself and the overall limitation we have to face. 
Then we describe different kind of problems we use as a benchmark of the application itself. 

\section{Smoothed Particle Hydrodynamics}
Smoothed Particle Hydrodynamics (SPH) is an explicit numerical mesh-free Lagrangian method.
It is used to solve hydrodynamical partial differential equations (PDEs)\index{Partial Differential Equations} by discretized them into a set of fluid elements called particles. 
This computational method was invented for the purpose of astrophysics simulations by Monaghan, Gingold and Lucy in 1977 \cite{lucy1977numerical,gingold1977smoothed}. 
This first SPH work conserved mass and they later proposed a method which also conserves linear and angular moment \cite{gingold1982kernel}. 
The method was extended for general fluid simulation and many more fields from ballistics to oceanography.
The development of new reliable, parallel and distributed tools for this method is a challenge for future HPC architectures with the upcoming Exascale systems.

\subsection{General description}
%
\begin{figure}[h!]
\centering
\begin{tikzpicture}
	
	% Others and their ellipse
	\draw [black!90,fill=black!40] (.5,1.5) circle (.3em);
	\draw [black!90,fill=black!40] (0,0) circle (.3em);
	\draw [black!90,fill=black!40] (0,3.2) circle (.3em);
	\draw[black!70] (0,3.2) ellipse (2 and .5);
	\draw [black!90,fill=black!40] (3,.2) circle (.3em);
	\draw[black!70] (3,.2) ellipse (2.5 and .7);
	\draw [black!90,fill=black!40] (4,4) circle (.3em);
	% Ellipses 
	\draw[line width=.8pt,black!70] (2,2) ellipse (4 and 1);
	% Axes
	\draw[->,line width=1pt] (2,2) -- (7,2) node[anchor=north west] {$r$};
	\draw[->,line width=1pt] (2,2) -- (2,6);
	% bezier for kernel 
	\draw[red,line width=1pt]  (6,2) .. controls (4,2.5) and (3.5,5) .. (2,5) node[red,anchor=east] {$W$};
	% main particle, at the end to cover
	\draw [black!90,fill=black!20!blue!60] (2,2) circle (.4em);
	% Arrows 
	\draw[->,line width=.8pt] (2,2) -- (.6,1.5) node[midway, above,xshift=-.5em] {$r\leq2h$};
\end{tikzpicture}
%\includegraphics[scale=.4]{\locpath/figures/flecsph/sph.pdf}
\caption{SPH kernel $W$ and smoothing length $h$ representation}
\label{fig:sph_base}
\end{figure}

The method, as illustrated in figure~\ref{fig:sph_base}, computes the evolution of physical quantities for every particle regarding its neighbors in the radius of its smoothing length $h$. 
The particles in this radius are then valued according to their distance using a smoothing function $W$, also called a kernel\index{Smoothing Kernel}. 
The fundamental SPH formulation for any physical quantity $A$ is then to compute with all the neighbors of $b$ of a $a$ particle by:
\begin{equation}
A(\vec{r})_a \simeq \sum_b \frac{m_b}{\rho_b} A(\vec{r}_b) W ( |\vec{r}-\vec{r}_b|,h)
\end{equation}

On a physics aspect, this method has several advantages:
it can handle deformations, low densities, vacuum, and makes particle tracking easier. 
It also conserves mass, linear and angular momenta, and energy by its construction that implies independence of the numerical resolution. 
Another strong benefit of using SPH is its exact advection of fluid properties. 
Furthermore, the particle structure of SPH easily combines with tree methods for solving Newtonian gravity through N-body simulations.
As a mesh-free method, it avoids the need of grid to calculate the spatial derivatives. 

However, there are cons to consider using SPH: 
it cannot be extend to all PDE formulations;
it requires careful setup of initial distribution of particles; 
further, it can be struggle to resolve turbulence-dominated flows and special care must be taken when handling high gradients such as shocks and surface structure of neutron stars.
Many works are leading to handle more cases and to push the limitations of this method \cite{dai2017dual,lind2016incompressible,ren2016dual}.\\

In this work, we are solving Lagrangian conservation equations (Euler equations) for density, energy and momentum of an ideal fluid ~\cite{Landau1959}  such that:
\begin{equation}
\frac{d \rho}{d t} = - \rho ( \nabla \cdot \vec{v}), \quad
\frac{d u}{d t} = - \frac{P}{\rho} ( \nabla \cdot \vec{v} ), \quad
\frac{d \vec{v}}{d t} = - \frac{1}{\rho} (\nabla P)
\end{equation}
with $\rho$ the density, $P$ the pressure, $u$ the internal energy and $v$ the velocity, where $d/dt = \partial/\partial_t + \vec{v} \cdot \nabla$ which is convective derivative.

By using the volume element $V_b = m_b / \rho_b$, we can formulate the Newtonian SPH scheme~\cite{rosswog2009} such that
\begin{equation}
\label{eq:rho}
\rho_a = \sum_b m_b W_{ab} (h_a)
\end{equation}
\begin{equation}
\frac{d u_a}{dt} = \frac{P_a}{\rho_a^2} \sum_b m_b \vec{v}_{ab} \cdot \nabla_a W_{ab} 
\end{equation}
\begin{equation}
\frac{d \vec{v}_a}{d t} = - \sum_b m_b \left(\frac{P_a}{\rho_a^2} + \frac{P_b}{\rho_b^2} \right) \nabla_a W_{ab}
\end{equation}
where $W_{ab} = W(| \vec{r}_a - \vec{r}_b |,h)$ is the smoothing kernel. 
The equations we would like to solve allow for emergence of discontinuities from smooth initial data. 
At discontinuities, the entropy increases in shocks. That dissipation occurs inside the shock-front. 
The SPH formulation here is inviscid so we need to handle this dissipation near shocks. 
There are a number of way to handle this problem, but the most widespread approach is to add artificial viscosity (or artificial dissipation) terms in SPH formulation such that:
\begin{equation}
\left(\frac{d u_a}{dt} \right)_{art} = \frac{1}{2} \sum_b m_b \Pi_{ab} \vec{v}_{ab} \cdot \nabla_a W_{ab}
\end{equation}
\begin{equation}
\left(\frac{d\vec{v}_a}{dt} \right)_{art} = - \sum_b m_b \Pi_{ab}\nabla_a W_{ab}
\end{equation}
In general, we can express the equations for internal energy and acceleration with artificial viscosity
\begin{equation}
\label{eq:intern}
\frac{d u_a}{dt} = \sum_b m_b \left(\frac{P_a}{\rho_a^2} + \frac{\Pi_{ab}}{2} \right) \vec{v}_{ab} \cdot \nabla_a W_{ab}
\end{equation}
\begin{equation}
\label{eq:velo}
\frac{d \vec{v}_a}{d t} = - \sum_b m_b \left(\frac{P_a}{\rho_a^2} + \frac{P_b}{\rho_b^2} + \Pi_{ab} \right) \nabla_a W_{ab}
\end{equation}
$\Pi_{ab}$ is the artificial viscosity tensor. 
As long as $\Pi_{ab}$ is symmetric, the conservation of energy, linear and angular momentum is assured by the form of the equation and antisymmetry of the gradient of kernel with respect to the exchange of indices $a$ and $b$. $\Pi_{ab}$ may define in different ways and here we use~\cite{Monaghan1983} such as: 
\begin{equation}
\Pi_{ab} = \begin{cases}
\frac{- \alpha \bar{c}_{ab} \mu_{ab} + \beta \mu_{ab}^2}{\bar{\rho}_{ab}} & \text{for $\vec{r}_{ab} \cdot \vec{v}_{ab} < 0$} \\
0 & \text{otherwise}
\end{cases}
\end{equation}
\begin{equation}
\mu_{ab} = \frac{\bar{h}_{ab} \vec{r}_{ab} \cdot \vec{v}_{ab}}{r^2_{ab} + \epsilon \bar{h}_{ab}^2}
\end{equation}

Using the usual form $c_s$ as $c_s = \sqrt{\frac{\partial p}{\partial \rho}}$.
The values of $\epsilon$, $\alpha$, and $\beta$ have to be set regarding the problem targeted. 
As an example we used for the Sod shock tube problem: $\epsilon = 0.01h^2$, $\alpha = 1.0$, and $\beta = 2.0$. 


There are many possibilities for the smoothing function, called the kernel. 
As an example the Monaghan's cubic spline kernel is given by:
\begin{equation}
W(\vec{r_{ij}},h) = \frac{\sigma}{h^D} \begin{cases}
1-\frac{3}{2} q^2 + \frac{3}{4} q^3 & \text{if} \indent 0 \leq q \leq 1 \\
\frac{1}{4} (2-q)^3  & \text{if} \indent 1 \leq q \leq 2 \\
0 & \text{otherwise}
\end{cases}
\end{equation}
where $q = r/h$, $r$ the distance between the two particles, $D$ is the number of dimensions and $\sigma$ is a normalization constant with the values:
\begin{equation}
\sigma =  \begin{cases}
\frac{2}{3} & \text{for 1D}  \\
\frac{10}{7 \pi} & \text{for 2D} \\
\frac{1}{\pi} & \text{for 3D}
\end{cases}
\end{equation}

In the computation of forces we also need to apply the gradient of the smoothing kernel. 
This is, in our example, for the cubic spline kernel:
\begin{equation}
 \vec{\nabla}_iW(\vec{r_{ij}},h) = \frac{\sigma}{h^{D+1}} \times \begin{cases} ( -\frac{3}{h} + \frac{9}{4h}q) \vec{r_{ij}}, & \mbox{si } 0 \leq \frac{r}{h} < 1 \\ (\frac{-3}{r} + \frac{3}{h} - \frac{3}{4h}q ) \vec{r_{ij}}, & \mbox{si } 1 \leq \frac{r}{h} < 2\\ 0, & \mbox{si } \frac{r}{h} \geq 2 \end{cases}
\end{equation}

\begin{figure}[ht!]
\centering
\begin{tikzpicture}
	\draw[->] (-7,0) -- (7,0) node[right] {$r$};
    \draw[->] (0,0) -- (0,2.5) node[above] {$W$};

    \foreach \v in {-3,-2,...,2,3}{
	   \draw (\v*2,.1) -- (\v*2,-.1) node[below] {\v};
    }

    \draw (-.1,2) -- (.1,2) node [above right] {1};

    \draw[very thick,scale=2,domain=0:1,smooth,variable=\r,blue] plot ({\r},{1-(3/2*\r*\r)+(3/4*\r*\r*\r)});
    \draw[very thick,scale=2,domain=0:1,smooth,variable=\r,blue] plot ({-\r},{1-(3/2*\r*\r)+(3/4*\r*\r*\r)});

    \draw[very thick, scale=2,domain=1:2,smooth,variable=\r,blue] plot ({\r},{1/4*(2-\r)*(2-\r)*(2-\r)});
    \draw[very thick, scale=2,domain=1:2,smooth,variable=\r,blue] plot ({-\r},{1/4*(2-\r)*(2-\r)*(2-\r)});

    \draw[very thick,scale=2,domain=2:3,smooth,variable=\r,red] plot ({\r},{0});
    \draw[very thick,scale=2,domain=2:3,smooth,variable=\r,red] plot ({-\r},{0});
\end{tikzpicture}
\caption{Cubic spline kernel example with $\sigma = 1$ and $h = 1$}
\label{fig:cubic_spline_function}
\end{figure}

Figure~\ref{fig:cubic_spline_function} is a representation of the cubic spline kernel with $\sigma = 1$ and $h = 1$. 
The abscissa axis represent $r$, distance between the particles and ordinate the value of the smoothing kernel.
When the support of the function, $2$ is reached the particles are ignored $W=0$, represented in red on the figure. 

To sum up, the SPH resolution scheme and its routines are presented on algorithm \ref{alg:sph}.
The Equation of State (EOS) and the integration are problem dependent and will be define for each test case in section \ref{sec:applications}. 

\begin{algorithm}
\caption{SPH loop algorithm}\label{alg:sph}
\begin{algorithmic}[1]
\While{not last step}
\State Compute density for each particle (\ref{eq:rho})
\State Compute pressure using EOS 
\State Compute acceleration from pressure forces (\ref{eq:velo})
\State Compute change of internal energy for acceleration (\ref{eq:intern})
\State Advance particles after integration
\EndWhile
\end{algorithmic}
\end{algorithm}

The main downside for the implementation of this method is the requirement for local computation on every particle. 
The particles have to be grouped locally to perform the computation of (\ref{eq:rho}), (\ref{eq:intern}) and (\ref{eq:velo}).
A communication step is needed before and after (\ref{eq:rho}) to get the local physical data to be able to compute (\ref{eq:intern}) and (\ref{eq:velo}).
The tree data structure allows us to perform $O(Nlog(N))$ neighbor search but also add a domain decomposition and distribution layer.

\subsection{Gravitation}
For classical problems like fluid flow the gravitation can directly be applied on the particles with the force:
\begin{equation}
	\vec{a_g} = m\vec{g}
\end{equation}

In order to consider astrophysics problems we need to introduce self-gravitation and gravitation. 
Each particle imply an action on the others base on its distance and mass. 
The equation of gravitation for a particle $i$ with $j$ other particles is: 
\begin{equation}
	\vec{f_a}_i = \sum_j -G \frac{m_i m_j}{|\vec{r_i}-\vec{r_j}|^3} \vec{r_{ij}}
	\label{eq:gravitation}
\end{equation}

This computation involve an $O(N^2)$ complexity and thus is not applicable directly. 
We applied the method called Fast Multipole Method, FMM and discussed in \cite{beatson1997short}.
This method is perfectly adapted to our tree representation of the domain and particles. 

This method aim to compute the gravitation up to an approximation determined by the user. 


\begin{figure}
\input{\locpath/figures/tikz/part3/gravitation}
\caption{Fast Multipole Method schematics. Particles to Multipole (P2M), Multipole to Multipole (M2M), Multipole to Particles (M2P), Multipole to Local (M2L), Local to Local (L2L) and Particles to Particles (P2P). Schematic inspired from \cite{yokota2011treecode}}
\end{figure}

This method is based on Taylor series.
The gravitation function of equation~\ref{eq:gravitation} can be approximate on a particle at position $\vec{r}$ by the gravitation computed at the centroid at position $\vec{r_c}$: 
\begin{equation}
 \vec{f}(\vec{r}) = \vec{f}(\vec{r_c}) + ||\frac{\partial\vec{f}}{\partial\vec{r}}||\cdot (\vec{r} - \vec{r_c}) + \frac{1}{2} (\vec{r}-\vec{r_c})^\intercal \cdot   ||\frac{\partial\vec{f}}{\partial\vec{r} \partial\vec{r}}|| \cdot (\vec{r} - \vec{r_c})
 \end{equation}

 From equation~\ref{eq:gravitation} we compute the term $||\frac{\partial\vec{f}}{\partial\vec{r}}||$:s
 \begin{equation}
\frac{\partial\vec{f}}{\partial\vec{r}} =
- \sum_p \frac{m_p}{|\vec{r_c}-\vec{r_p}|^3}
\begin{bmatrix}
1 - \frac{3(x_c-x_p)(x_c-x_p)}{|\overline{r_c}-\overline{r_p}|^2} & -\frac{3(y_c-y_p)(x_c-x_p)}{|\overline{r_c}-\overline{r_p}|^2}  & -\frac{3(z_c-z_p)(x_c-x_p)}{|\vec{r_c}-\vec{r_p}|^2}  \\
-\frac{3(x_c-x_p)(y_c-y_p)}{|\vec{r_c}-\vec{r_p}|^2}  & 1 - \frac{3(y_c-y_p)(y_c-y_p)}{|\vec{r_c}-\vec{r_p}|^2} &  -\frac{3(z_c-z_p)(y_c-y_p)}{|\vec{r_c}-\vec{r_p}|^2}\\
- \frac{3(x_c-x_p)(z_c-z_p)}{|\vec{r_c}-\vec{r_p}|^2}   &  -\frac{3(y_c-y_p)(z_c-z_p)}{|\vec{r_c}-\vec{r_p}|^2} &  1- \frac{3(z_c-z_p)(z_c-z_p)}{|\vec{r_c}-\vec{r_p}|^2} \\
\end{bmatrix}
 \end{equation}

And we propose a compact version of the matrix with: 
 
\begin{equation}
 ||\frac{\partial f^a}{\partial r^b}|| = -\sum_c \frac{m_c}{|\vec{r}-\vec{r_c}|^3} \Big[ \delta_{ab} - \frac{3.(r^a-r_c^a)(r^b-r_c^b)}{|\vec{r}-\vec{r_c}|^2} \Big] 
\end{equation}

With $\delta_{ab}$ the Kronecker delta:
\begin{equation}
\delta_{ab} = 
\begin{cases}
    1, & \text{if $a = b$}.\\
    0, & \text{if $a\neq b$}.
  \end{cases}
\end{equation}

We note that $a$ and $b$ variate from 0 to 2 and $r^0=x$, $r^1=y$, and $r^2=z$ as usual sense. 

For the term $||\frac{\partial\vec{f}}{\partial\vec{r} \partial\vec{r}}||$ we give the compact version by:
\begin{equation}
\begin{aligned}
||\frac{\partial^2 f^a}{\partial r^b \partial r^c}|| = - \sum_c \frac{3 m_c}{|\vec{r}-\vec{r_c}|^5} \Big[ & \frac{5(r^a-r_c^a)(r^b-r_c^b)(r^c-r_c^c)}{|\vec{r}-\vec{r_c}|^2} - \\ 
		 & \left( \delta_{ab} (r^c-r_c^c)+\delta_{bc} (r^a-r_c^a)+\delta_{ac} (r^b-r_c^b) \right) \Big] 
\end{aligned}
\end{equation} 

 \begin{figure}
 \end{figure}

The method is summed up in figure with the different equations.
We consider Centers Of Mass, COM, to be the centroid of particles based on their position. 
In several steps the information is first transmitted to the COMs, computing their position and mass. 


\section{Applications of SPH} 
\label{sec:applications}
The previous equations are generic and describe the behavior of SPH method. 
In order to check our 

\subsection{Sod shock tube}
The Sod shock tube is the test consisting of a one-dimensional Riemann problem with the following initial parameters~\cite{sod1978}.
\begin{equation}
(\rho, v, p)_{t=0} = \begin{cases}
(1.0,0.0,1.0) & \text{if} \indent 0 < x \leq 0.5 \\
(0.125,0.0,0.1) & \text{if} \indent 0.5 < x < 1.0
\end{cases}
\end{equation}
In our code, we use the same initial data as in section \ref{sec:intro_sph} with ideal gas EOS such as:
\begin{equation}
P(\rho,u) = (\Gamma - 1) \rho u
\end{equation}
where $\Gamma$ is the adiabatic index of the gas, we set $\Gamma = 5/3$. 

\begin{figure}[t!]
\centering
\includegraphics[width=\columnwidth]{\locpath/figures/sph/{sodtube_width}.png}
\caption{Sod shock tube with FleCSPH}
\label{fig:sodtube}
\end{figure}

This test is used to check the physical accuracy of the code and thus the tree search itself.
A simulation of our Sod shock experimentation is presented on Fig.~\ref{fig:sodtube} and shows physically correct results. 

\subsection{Sedov blast wave}
A blast wave is the pressure and flow resulting from the deposition of a large amount of energy in a small very localized volume. 
There are different versions of blast wave test and we consider comparing it with the analytic solution for a point explosion as given by Sedov~\cite{sedov1946}, making the assumption that the atmospheric pressure relative to the pressure insider the explosion negligible. 
Here, we test 2D blast wave. In this simulation, we use ideal gas EOS with $\Gamma = 5/3$ and we are assuming that the undistributed area is at rest with a pressure $P_0 = 1.0 \time 10^{-5}$. The density is constant $\rho_0$, also in the pressurized region. 

\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{\locpath/figures/sph/{sedov_flecsph_results}}
\caption{Sedov Blast Wave with FleCSPH at respectively $t=0.01$, $t=0.03$, $t=0.06$ and $t=0.1$}
\label{fig:sedov}
\end{figure}

An example of our Sedov Blast wave experimentation is presented on Fig.~\ref{fig:sedov} and shows physically correct results.

\subsection{Fluid flow}
After performing the tests regarding the physics reliability, we worked on fluid flow problem in 2D and 3D to reach high number of particles. 
The details can be found in \cite{gomez2012sphysics}.
This test is based on an ideal EOS given by:
\begin{equation}
P = B \Big[ \big( \frac{\rho}{\rho_0} \Big)^\gamma -1 \Big] 
\end{equation}
with $\gamma = 7$ and $B = c_0\rho_0/\gamma$ being $\rho_0 = 1000 \, kg.m^{-3}$ the reference density.

\begin{figure}[t!]
\centering
\begin{tikzpicture}[thick]
% Mathematical reflection
\draw (0.3,.8) circle (.25cm) node[pos=.5] (p0) {};
\draw (1,.6) circle (.25cm) node[pos=.5] (p1) {};
\draw (2.3,1) circle (.25cm) node[pos=.5] (p2) {};
\draw (0,0) -- (3,0);
\foreach \i in {1,...,6}{
	\draw[black!20] (.5*\i-.5,-1) -- (.5*\i,0);
}
% Forces
\foreach \i in {1,...,7}{
	\draw[->] (.375*\i,0) -- (.375*\i,.3);
}
\node at (1.5,-2) {Repulsive force};

% Mirror 
\draw (4.3,.8) circle (.25cm) node[pos=.5] (p0) {};
\draw (5,.6) circle (.25cm) node[pos=.5] (p1) {};
\draw (6.3,1) circle (.25cm) node[pos=.5] (p2) {};
\draw[black!50] (4.3,-.8) circle (.25cm) node[pos=.5] (mii1) {};
\draw[black!50] (5,-.6) circle (.25cm) node[pos=.5] (mii2) {};
\draw[black!50] (6.3,-1) circle (.25cm) node[pos=.5] (mii3) {};
\draw[black!20,dotted] (4,0) -- (7,0);
\foreach \i in {1,...,6}{
	\draw[black!20] (.5*\i-.5+4,-1) -- (.5*\i+4,0);
}
\node at (5.5,-2) {Mirror particles};

% Dummies
\draw[black!50,fill=black!10] (8.25,0) circle (.25cm) node[pos=.5] (d0) {};
\draw[black!50,fill=black!10] (9.08,0) circle (.25cm) node[pos=.5] (d1) {};
\draw[black!50,fill=black!10] (9.91,0) circle (.25cm) node[pos=.5] (d2) {};
\draw[black!50,fill=black!10] (10.75,0) circle (.25cm) node[pos=.5] (d3) {};
% second layer
\draw[black!50,fill=black!10] (8.66,-.5) circle (.25cm) node[pos=.5] (d4) {};
\draw[black!50,fill=black!10] (9.50,-.5) circle (.25cm) node[pos=.5] (d5) {};
\draw[black!50,fill=black!10] (10.33,-.5) circle (.25cm) node[pos=.5] (d6) {};
%\draw (1,-.25) circle (.25cm) node[pos=.5] (d4) {};
%normal parts
\draw (8.3,.8) circle (.25cm) node[pos=.5] (p0) {};
\draw (9,.6) circle (.25cm) node[pos=.5] (p1) {};
\draw (10.3,1) circle (.25cm) node[pos=.5] (p2) {};
\draw[dotted,black!20] (8,0) -- (11,0);
\foreach \i in {1,...,6}{
	\draw[black!20] (.5*\i-.5+8,-1) -- (.5*\i+8,0);
}
\node at (9.5,-2) {Dummy particles};
\end{tikzpicture}
\caption{Different boundaries condition methods}
\label{fig:SPH:boundaries}
\end{figure}

For this experiment, realistic boundaries conditions were needed. 
Several methods are possible with SPH we focused on the main ones, the repulsive wall, the mirror particles \cite{libersky1991smooth} and the dummies particles implementation \cite{adami2012generalized}. 
Those boundaries conditions implementation are presented in figure~\ref{fig:SPH:boundaries}.

For the current implementation, we used the dummies particles method.
The wall particles are just considered as normal particles, with specific equations, and their quantities are evolved during the run. 
The main difference is that their position does not evolve at the end of the step.
They are identified in the code with a specific type, provided during the data generation. 

\subsection{Astrophysics: neutron stars coalescence}

The final aim of our tests is to simulate astrophysical events. 
We are interested in one of the most important event recently discovered. 
Last year the Laser Interferometer Gravitational Wave, LIGO, detected the first gravitational wave generated by binary neutron stars merging \cite{abbott2017gw170817} and also more complexes event with Binary Black Holes coalescence in \cite{abbott2017gw170814}.


\subsubsection{Solving Lane-Emden Equation}

We need to determine the density function based on the radius. 

As we consider the star as a polytropic fluid, we use the equation of Lane-Emden which is a form of the Poisson equation: 

\begin{equation}\label{eq_LaneEmden}
  \frac{d^2\theta}{d \xi^2}+ \frac{2}{\xi}\frac{d\theta}{d\xi}+\theta^n = 0
\end{equation}

With $\xi$ and $\theta$ two dimensionless variables. 
There is only exact solutions for a polytropic index $n = 0.5$, $1$ and $2$.
In our work we use a polytropic index of $1$ which can correspond to a NS simulation.

For $n=1$ the solution of equation \ref{eq_LaneEmden} is: 

\begin{equation}
\theta(\xi)=\frac{sin(\xi)}{\xi}
\end{equation}

We note $\xi_1 = \pi$, the first value of $\xi$ as $\theta(\xi) = 0$.
$\theta(\xi)$ is also defined as: 
\begin{equation}
 \theta(\xi) = \Big(\frac{\rho(\xi)}{\rho_c}\Big)^{\frac{1}{n}}  = \frac{\rho(\xi)}{\rho_c}
\end{equation}

With $\rho_c$ the internal density of the star and $\rho$ the density at a determined radius. $\xi$ is defined as:  
$$ \xi = Ar = \sqrt{\frac{4\pi G}{K(n+1)}\rho_c^{(n-1)/n}} \times r = \sqrt{\frac{2\pi G}{K}}\times r \mbox{ (for } n=1 \mbox{)}$$

With $K$ a proportionality constant.

From the previous equations we can write the stellar radius $R$ as:
\begin{equation}
R = \sqrt{\frac{K(n+1)}{4\pi G}}\rho_c^{(1-n)/2}\xi_1 = \sqrt{ \frac{K}{2\pi G} } \times \xi_1
\end{equation} 

(We note that for $n=1$ the radius does not depend of the central density.)

If, for example, we use dimensionless units as $G=R=M=1$ (for the other results we use CGS with $G = 6.674 \times 10^{-8} cm^3g^{-1}s^{-2}$) 
We can compute K as: 
\begin{equation}
\label{eq:constant}
K = \frac{R^2  2 \pi G}{\xi_1^2}
\end{equation}

\begin{center}
\begin{tabular}{c|c|c|c|c|}
 & $NS_1$ & $NS_2$ & $NS_3$ & $NS_4$ \\ 
\hline 
Radius (cm) & $R=G=M=1$ & 1500000 & 1400000 & 960000 \\ 
\hline 
K & 0.636619 & 95598.00 & 83576.48 & 39156.94\\ 
\hline 
\end{tabular}
\end{center} 

Then we deduce the density function of $r$ as :

$$\rho(\xi) = \frac{sin(A\times r)}{A \times r} \times \rho_c \mbox{ with } A = \sqrt{\frac{2\pi G}{K}}
$$

As we know the total Mass $M$, the radius $R$ and the gravitational constant $G$ we can compute the central density as: 

$$ \rho_c = \frac{M A^3}{4 \pi (sin(AR)-ARcos(AR)) } $$

Then we normalize the results to fit $R = M = G = 1$: $K' = K/(R^2G) $, $m_i' = m_i/M $, $h_i' = h_i / R$, $\vec{x_i}' = \vec{x_i}/R$ 

\section{Conclusion}
As the SPH method is used in a large panel of fields from astrophysics to fluid mechanic, there are numerous related works. 
We can cite a code developed in the LANL, 2HOT \cite{warren20132hot} that introduced the Hashed Oct Tree structure used in our implementation. 
There is also GADGET-2 \cite{springel2005cosmological}, GIZMO \cite{hopkins2014gizmo} and the most recent publication is GASOLINE \cite{wadsley2017gasoline2} based on PKDGRAV, a specific tree+gravity implementation. 
Several implementations already implement GPU code and tree construction and traversal, one can cite GOTHIC \cite{miki2017gothic}, presenting gravitational tree code accelerated using the latest Fermi, Kepler and Maxwell architectures. But a lot of GPU accelerated work still focused on fluid problems and not on astrophysical problems  \cite{harada2007smoothed,crespo2011gpus}.
We also note that these implementations focus on SPH problems and does not provide a general purpose and multi-physics framework like we intent to provide through FleCSPH and FleCSI. 

